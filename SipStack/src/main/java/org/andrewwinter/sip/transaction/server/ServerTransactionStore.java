package org.andrewwinter.sip.transaction.server;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import org.andrewwinter.sip.parser.SipRequest;
import org.andrewwinter.sip.parser.Via;

/**
 *
 * @author andrewwinter77
 */
public class ServerTransactionStore {
    
    private final Map<String, ServerTransaction> txnMap;
    
    private static ServerTransactionStore INSTANCE = new ServerTransactionStore();
    
    /**
     *
     * @return
     */
    public static ServerTransactionStore getInstance() {
        return INSTANCE;
    }
    
    private ServerTransactionStore() {
        txnMap = new HashMap<String, ServerTransaction>();
    }
    
    /**
     * 
     * @param txn The server transaction to be stored.
     */
    public void put(final ServerTransaction txn) {
        final SipRequest request = txn.getInboundSipRequest().getRequest();
        final String key = generateIndexIntoMap(request.getMethod(), request.getTopmostVia());
        txnMap.put(key, txn);
        System.out.println("Server Txn count: " + txnMap.keySet().size());
    }
    
    /**
     * Returns null if there are no matching transactions;
     * @param request
     * @return 
     */
    public ServerTransaction get(final SipRequest request) {
        
        String method = request.getMethod();
        
        
        // The TU determines the transaction to be cancelled by taking the
        // CANCEL request, and then assuming that the request method is anything
        // but CANCEL or ACK and applying the transaction matching procedures of
        // Section 17.2.3.
        
        // TODO: This doesn't handle CANCEL cancelling anything other than INVITEs. This should be OK now but probably isn't future proof.
        if ("CANCEL".equals(method)) {
            method = "INVITE";
        }
        final String key = generateIndexIntoMap(method, request.getTopmostVia());
        return txnMap.get(key);
    }

    /**
     *
     * @param txn
     */
    public void remove(final ServerTransaction txn) {
        final SipRequest request = txn.getInboundSipRequest().getRequest();
        final String key = generateIndexIntoMap(request.getMethod(), request.getTopmostVia());
        txnMap.remove(key);
    }
    
    private static String generateIndexIntoMap(String method, final Via topmostVia) {

        // The branch parameter in the topmost Via header field of the request
        // is examined. If it is present and begins with the magic cookie
        // ???z9hG4bK???, the request was generated by a client transaction
        // compliant to this specification.
        
        final String branch = topmostVia.getBranch();
        if (branch != null && branch.startsWith(Via.MAGIC_COOKIE)) {
        
            final String sentBy = topmostVia.getSentBy().toLowerCase(Locale.US);

            // 1. the branch parameter in the request is equal to the one in the
            // top Via header field of the request that created the transaction,
            // and
            // 2. the sent-by value in the top Via of the request is equal to
            // the one in the request that created the transaction,
            // and
            // 3. the method of the request matches the one that created the
            // transaction, except for ACK, where the method of the request that
            // created the transaction is INVITE.
            
            if (method.equals("ACK")) {
                method = "INVITE";
            }
            
            // [Use '/' as a delimiter because it isn't allowed in a method
            // name or a branch tag]
            return method + "/" + branch + "/" + sentBy;
        
        } else {
            // TODO: Add backwards compatibility with RFC 2543. See p101.
            return null;
        }
    }
}
